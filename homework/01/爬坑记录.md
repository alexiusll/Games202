# 任务一

需要实现 shadow map



## step.01

这里首先需要修改 lights/DirectionalLight.js中的 **CalcLightMVP** 函数。这里会用到 **mat4** 这个方法来创建矩阵。

推测应该是使用了 gl-matrix 这个矩阵的库，主要使用了 **mat4**，它的API请看：

https://glmatrix.net/docs/module-mat4.html



这里相当于从光源设置一个 正交投影的虚拟摄像机

**homework\01\src\lights\DirectionalLight.js**

```javascript
  // 作业 1 修改处
  // 它会在 ShadowMaterial 中被调用，并将返回光源处的 MVP 矩阵绑定从而完成参数传递过程。
  CalcLightMVP(translate, scale) {
    let lightMVP = mat4.create();
    let modelMatrix = mat4.create();
    let viewMatrix = mat4.create();
    let projectionMatrix = mat4.create();

    // Model transform
    // * translate(out, a, v)
    mat4.translate(modelMatrix, modelMatrix, translate); //平移

    // * scale(out, a, v)
    mat4.scale(modelMatrix, modelMatrix, scale); //缩放

    // View transform
    // * lookAt(out, eye, center, up)
    mat4.lookAt(viewMatrix, this.lightPos, this.focalPoint, this.lightUp); //Camera的lookup矩阵

    // Projection transform
    // * ortho(out, left, right, bottom, top, near, far)
    mat4.ortho(projectionMatrix, -500, 500, -500, 500, 0.1, 1000); //正交投影

    // * 这里的转换方程为 projectionMatrix * viewMatrix * modelMatrix
    mat4.multiply(lightMVP, projectionMatrix, viewMatrix);
    mat4.multiply(lightMVP, lightMVP, modelMatrix);

    return lightMVP;
  }
```



这样就会生成一个 500 * 500 精度的贴图



## step.02

需要完善 phongFragment.glsl 中的 

**useShadowMap(sampler2D shadowMap, vec4 shadowCoord)** 函数。

该函数负责查询当前着色点在 ShadowMap 上记录的深度值，并与转换到 light space 的深度值比较后返回 visibility 项（请注意，使用的查询坐标需要先转换到 NDC 标准空间 [0,1]）。



修改后的函数

**homework\01\src\shaders\phongShader\phongFragment.glsl**

```glsl

```



## 执行过程解析
